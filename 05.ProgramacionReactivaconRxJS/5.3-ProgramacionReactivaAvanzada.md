# Programaci√≥n reactiva avanzada

## Creaci√≥n y gesti√≥n de observables
Un **Observable** es una colecci√≥n de valores o eventos que pueden ser **emitidos en el tiempo**, y a los cuales uno se puede **suscribir** para reaccionar a ellos.
> Es como una radio: vos te sintoniz√°s (te suscrib√≠s) y escuch√°s lo que emite (los valores).

### üõ†Ô∏è Creaci√≥n de Observables
```ts
import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  observer.next('Hola');
  observer.next('Mundo');
  observer.complete();
});
```

###  Usando funciones auxiliares (of, from)
```ts
import { of, from } from 'rxjs';

const obs1 = of(1, 2, 3); // Emite valores individuales
const obs2 = from([10, 20, 30]); // Emite cada valor de un array
```

### üëÇ Suscripci√≥n a un Observable
```ts
obs1.subscribe({
  next: valor => console.log('Valor:', valor),
  error: err => console.error('Error:', err),
  complete: () => console.log('Completado')
});
```
Tambi√©n pod√©s suscribirte con una funci√≥n directa si no necesitas manejar errores:
```ts
obs2.subscribe(valor => console.log(valor));
```

## üîÑ Operadores comunes de RxJS

| Operador     | Uso principal                                                  |
|--------------|----------------------------------------------------------------|
| `map`        | Transformar valores emitidos.                                  |
| `tap`        | Depurar o realizar acciones secundarias.                       |
| `forkJoin`   | Esperar m√∫ltiples observables a la vez.                        |
| `mergeMap`   | Combinar flujos m√∫ltiples (sin cancelar anteriores).           |
| `switchMap`  | Cancelar solicitudes anteriores y mantener solo la √∫ltima.     |

> üìå **Clave de √©xito:** Usar correctamente `pipe` con operadores de **RxJS** te da control total sobre el flujo de datos y mejora la performance de tu app.

## üß† Diferencias entre Observables y Subjects

| Caracter√≠stica   | Observables                                 | Subjects                                     |
|------------------|---------------------------------------------|----------------------------------------------|
| **Rol**          | Solo productor de datos                     | Productor y consumidor de datos              |
| **Suscriptores** | Cada uno recibe valores de forma independiente | Todos reciben el mismo flujo de datos     |
| **Creaci√≥n**     | Usados en tareas espec√≠ficas                | Usados para compartir estados globales       |


## ‚öîÔ∏è `mergeMap` vs `switchMap`

| Operador    | Comportamiento                          |
|-------------|------------------------------------------|
| `mergeMap`  | Conserva todas las suscripciones.        |
| `switchMap` | Cancela suscripciones anteriores.        |

## üß™ Ejemplo pr√°ctico: Fetch con Observables en Angular
```ts
this.http.get('https://jsonplaceholder.typicode.com/users')
  .pipe(
    tap(() => console.log('Cargando usuarios...')),
    map((res: any) => res.slice(0, 5))
  )
  .subscribe(data => {
    this.usuarios = data;
  });
```

## üßº Cancelar suscripciones
Si no gestion√°s bien tus suscripciones, te vas a comer un memory leak üçù.
```ts
import { Subscription } from 'rxjs';

export class MiComponente {
  private sub!: Subscription;

  ngOnInit() {
    this.sub = this.servicio.getDatos().subscribe(data => {
      console.log(data);
    });
  }

  ngOnDestroy() {
    this.sub.unsubscribe(); // ¬°Liber√° memoria!
  }
}
```

## ‚úÖ Resumen

- Los **Observables** permiten trabajar con **flujos de datos as√≠ncronos**.
- Se pueden crear con `new Observable`, `of`, `from`, etc.
- Se gestionan con operadores como `map`, `tap`, `mergeMap`, etc., y se consumen con `subscribe`.
- ‚ö†Ô∏è Siempre record√° **cancelar las suscripciones** para evitar problemas de memoria (memory leaks).

> üöÄ **Dominar los Observables es clave para hacer apps Angular limpias, reactivas y bien organizadas.**

## M√©todos next, error y complete en Observables
Los observables en RxJS tienen un ciclo de vida controlado por tres m√©todos principales: `next`, `error` y `complete`. Estos m√©todos permiten manejar la emisi√≥n de datos, los errores y la finalizaci√≥n de un flujo de forma eficiente.

- **M√©todos Clave**
    - `next()`:
        - Emite un valor desde el observable al suscriptor.
        - Se usa para enviar datos continuamente mientras el observable est√° activo.
    - `error()`:
        - Se ejecuta cuando ocurre un error durante el flujo de datos.
        - Detiene la emisi√≥n de valores y finaliza el flujo inmediatamente.
    - `complete()`:
        - Indica que el flujo de datos ha terminado.
        - No se emiten m√°s valores despu√©s de la llamada a `complete()`.
- **Ejemplo Pr√°ctico**
    - En este ejemplo, se crea un observable que emite una serie de valores, simula un error de forma aleatoria y, si no hay error, finaliza correctamente.
    ```ts
    import { Observable } from 'rxjs';

    const observable = new Observable(observer => {
        observer.next('Valor 1'); // Emitir primer valor
        observer.next('Valor 2'); // Emitir segundo valor

        if (Math.random() > 0.5) {
            observer.error('Ocurri√≥ un error'); // Emitir error aleatorio
        } else {
            observer.complete(); // Completar el flujo
        }
    });

    observable.subscribe({
        next: valor => console.log('Emitido:', valor),
        error: err => console.error('Error:', err),
        complete: () => console.log('Flujo completado'),
    });
    ```
- **Flujo de Eventos**: El ciclo de vida de un observable var√≠a seg√∫n los eventos que ocurren. A continuaci√≥n, se ilustran los posibles flujos de eventos.
    - Cuando **no hay errores**:
        - `next('Valor 1') ‚Üí next('Valor 2') ‚Üí complete()`
        - Salida esperada:
            - Emitido: Valor 1
            - Emitido: Valor 2
            - Flujo completado
    - Cuando **ocurre un error**:
        - `next('Valor 1') ‚Üí next('Valor 2') ‚Üí error('Ocurri√≥ un error')`
        - Salida esperada:
            - Emitido: Valor 1
            - Emitido: Valor 2
            - Error: Ocurri√≥ un error
        - En este flujo, el m√©todo error() finaliza inmediatamente la ejecuci√≥n del observable, por lo que no se llama a complete().

### Aplicaciones en Angular
Los m√©todos next, error y complete se utilizan para manejar eventos asincr√≥nicos, especialmente en flujos de datos generados por observables.
- **Usos de next()**
    - **Solicitudes HTTP**: Captura la respuesta de una API y la procesa.
    - **Eventos de Usuario**: Registra eventos de clic, entrada de texto o interacciones.
    - **Emisi√≥n de Datos**: Usa `next()` para enviar valores a otros componentes o servicios.
- **Usos de error()**
    - **Gesti√≥n de Errores de API**: Controla errores en solicitudes HTTP (404, 500, etc.).
    - **Notificaciones de Errores**: Muestra mensajes de error en la interfaz de usuario.
    - **Tareas As√≠ncronas**: Controla los fallos de promesas o procesos as√≠ncronos.
- **Usos de complete()**
    - **Liberaci√≥n de Recursos**: Cierra flujos para liberar memoria.
    - **Finalizaci√≥n de Observables**: Cierra observables que ya no son necesarios.
    - **Control de Suscripciones**: Evita fugas de memoria al cerrar la suscripci√≥n de forma controlada.

### Conclusi√≥n
Los m√©todos next, error y complete permiten controlar el ciclo de vida de un observable en Angular.
- `next()`: Emite datos.
- `error()`: Gestiona errores de forma controlada.
- `complete()`: Finaliza el flujo de forma limpia.

> Comprender su uso es fundamental para manejar flujos de datos din√°micos y asincr√≥nicos, especialmente en aplicaciones reales y reactivas. Estos m√©todos permiten controlar la emisi√≥n de valores, la gesti√≥n de errores y la finalizaci√≥n de flujos de manera eficiente.


# **Gesti√≥n Avanzada de Suscripciones en Angular**
En Angular, la gesti√≥n adecuada de suscripciones a observables es fundamental para evitar problemas de **rendimiento** y **fugas de memoria**. Los observables que no se cierran correctamente siguen activos, consumiendo recursos innecesarios, lo que puede provocar una reducci√≥n de la eficiencia de la aplicaci√≥n.

## **Problemas Comunes con las Suscripciones**
Cuando los componentes no cierran sus suscripciones al destruirse, los observables contin√∫an activos, lo que provoca los siguientes problemas:

- **Fugas de memoria**: Los recursos de la aplicaci√≥n no se liberan adecuadamente.
- **Baja eficiencia**: Incremento del consumo de memoria y uso del procesador.
- **Inconsistencias**: Se pueden recibir datos de componentes que ya no existen.

## **Estrategias para Gestionar Suscripciones**

### **Patr√≥n `unsubscribe()`**

El patr√≥n **`unsubscribe()`** permite cerrar manualmente las suscripciones cuando se destruye el componente. Este m√©todo se usa com√∫nmente en el ciclo de vida `ngOnDestroy()`.

### **Ejemplo Pr√°ctico**
```ts
import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  observer.next('Valor 1'); // Emitir primer valor
  observer.next('Valor 2'); // Emitir segundo valor

  if (Math.random() > 0.5) {
    observer.error('Ocurri√≥ un error'); // Emitir error aleatorio
  } else {
    observer.complete(); // Completar el flujo
  }
});

observable.subscribe({
  next: valor => console.log('Emitido:', valor),
  error: err => console.error('Error:', err),
  complete: () => console.log('Flujo completado'),
});
```
- **Flujo de Eventos**: El ciclo de vida de un observable var√≠a seg√∫n los eventos que ocurren. A continuaci√≥n, se ilustran los posibles flujos de eventos.
- Cuando **no hay errores**:
    - `next('Valor 1') ‚Üí next('Valor 2') ‚Üí complete()`
    - Salida esperada:
        - Emitido: Valor 1
        - Emitido: Valor 2
        - Flujo completado
- Cuando **ocurre un error**:
    - `next('Valor 1') ‚Üí next('Valor 2') ‚Üí error('Ocurri√≥ un error')`
    - Salida esperada:
        - Emitido: Valor 1
        - Emitido: Valor 2
        - Error: Ocurri√≥ un error

> En este flujo, el m√©todo `error()` finaliza inmediatamente la ejecuci√≥n del observable, por lo que no se llama a` complete()`.

- **Aplicaciones en Angular**: En Angular, los m√©todos `next`, `error` y `complete` se utilizan para manejar eventos asincr√≥nicos, especialmente en flujos de datos generados por observables.
    - 1Ô∏è‚É£ Usos de next()
        - Solicitudes HTTP: Captura la respuesta de una API y la procesa.
        - Eventos de Usuario: Registra eventos de clic, entrada de texto o interacciones.
        - Emisi√≥n de Datos: Usa next() para enviar valores a otros componentes o servicios.
    - 2Ô∏è‚É£ Usos de error()
        - Gesti√≥n de Errores de API: Controla errores en solicitudes HTTP (404, 500, etc.).
        - Notificaciones de Errores: Muestra mensajes de error en la interfaz de usuario.
        - Tareas As√≠ncronas: Controla los fallos de promesas o procesos as√≠ncronos.
    - 3Ô∏è‚É£ Usos de complete()
        - Liberaci√≥n de Recursos: Cierra flujos para liberar memoria.
        - Finalizaci√≥n de Observables: Cierra observables que ya no son necesarios.
        - Control de Suscripciones: Evita fugas de memoria al cerrar la suscripci√≥n de forma controlada.

## Gesti√≥n Avanzada de Suscripciones
En Angular, gestionar correctamente las suscripciones a observables es fundamental para evitar problemas de rendimiento, como fugas de memoria. Esta gu√≠a presenta estrategias avanzadas utilizando el patr√≥n unsubscribe y el operador takeUntil para manejar suscripciones de manera eficiente.

### Problemas Comunes con las Suscripciones
Cuando los componentes no cierran sus suscripciones al destruirse, los observables contin√∫an activos, consumiendo recursos innecesariamente. Esto puede generar:
    - **P√©rdidas de memoria**: Acumulaci√≥n de recursos no utilizados.
    - **Baja eficiencia**: Incremento del consumo de memoria y procesamiento.

## Estrategias para Gestionar Suscripciones
- **Patr√≥n darse de baja**
    - El m√©todo `unsubscribe()` permite cerrar manualmente las suscripciones en el ciclo de vida del componente, espec√≠ficamente en el m√©todo `ngOnDestroy`.
    - Ejemplo pr√°ctico:
    ```ts
    import { Component, OnDestroy } from '@angular/core';
    import { Subscription, interval } from 'rxjs';

    @Component({
        selector: 'app-example',
        template: `<p>Ejemplo con unsubscribe...</p>`,
    })

    export class ExampleComponent implements OnDestroy {
        private subscription: Subscription;

        constructor() {
            this.subscription = interval(1000).subscribe(val => console.log(val));
        }

        ngOnDestroy(): void {
            this.subscription.unsubscribe(); // Cerrar manualmente la suscripci√≥n
            console.log('Suscripci√≥n cerrada');
        }
    }
    ```
    - **Ventajas**: F√°cil de implementar para una o pocas suscripciones.
    - **Desventajas**: - Propenso a errores si se olvida llamar a unsubscribe().
- **Operador takeUntil**
    - El operador takeUntil utiliza un Asunto para automatizar el cierre de suscripciones. Cuando se emite un valor desde el Subject, todas las suscripciones asociadas finalizan autom√°ticamente.
    - Ejemplo pr√°ctico:
    ```ts
    import { Component, OnDestroy } from '@angular/core';
    import { Subject, interval } from 'rxjs';
    import { takeUntil } from 'rxjs/operators';

    @Component({
        selector: 'app-example',
        template: `<p>Ejemplo con takeUntil...</p>`,
    })

    export class ExampleComponent implements OnDestroy {
        private destroy$ = new Subject<void>();

        constructor() {
            interval(1000)
            .pipe(takeUntil(this.destroy$))
            .subscribe(val => console.log(val));
        }

        ngOnDestroy(): void {
            this.destroy$.next(); // Emitir se√±al para cerrar suscripciones
            this.destroy$.complete(); // Completar el Subject
            console.log('Suscripciones gestionadas con takeUntil');
        }
    }
    ```
    - **Ventajas**:
        - Automatiza el cierre de m√∫ltiples suscripciones.
        - Ideal para componentes con varios observables.
    - **Desventajas**: Requiere un Asunto adicional.

### üì§ M√©todos para cancelar suscripciones en RxJS

| M√©todo         | Ventajas                                         | Desventajas                                |
|----------------|--------------------------------------------------|---------------------------------------------|
| **Darse de baja** (`unsubscribe()`) | Control directo sobre cada suscripci√≥n.       | Riesgo de olvidar llamar a `unsubscribe()`. |
| **`takeUntil`** | Automatiza el cierre de m√∫ltiples suscripciones. | Requiere un `Subject` adicional.            |

> üß† Tip pro: Usar takeUntil con un `Subject` en `ngOnDestroy()` es la forma m√°s segura y limpia de manejar la destrucci√≥n de m√∫ltiples suscripciones en Angular.

### Diagrama sugerido
- **Darse de baja**: L√≠nea continua de eventos conectada a un nodo donde se llama manualmente a unsubscribe()para detener el flujo.
- **tomarHasta**: Varias l√≠neas de observables que convergen en un Subject, el cual emite una se√±al para detener autom√°ticamente todas las suscripciones.

**Conclusi√≥n**
La gesti√≥n adecuada de suscripciones es esencial para mantener el rendimiento y evitar problemas de memoria en aplicaciones Angular. Para escenarios simples, el patr√≥n darse de baja es suficiente. Sin embargo, en aplicaciones m√°s complejas, el uso del operador toma hasta mejorar la escalabilidad y automatiza la limpieza de suscripciones, asegurando un manejo eficiente de los recursos.