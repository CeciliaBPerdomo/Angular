# ProgramaciÃ³n reactiva avanzada

## CreaciÃ³n y gestiÃ³n de observables
Un **Observable** es una colecciÃ³n de valores o eventos que pueden ser **emitidos en el tiempo**, y a los cuales uno se puede **suscribir** para reaccionar a ellos.
> Es como una radio: vos te sintonizÃ¡s (te suscribÃ­s) y escuchÃ¡s lo que emite (los valores).

### ðŸ› ï¸ CreaciÃ³n de Observables
```ts
import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  observer.next('Hola');
  observer.next('Mundo');
  observer.complete();
});
```

###  Usando funciones auxiliares (of, from)
```ts
import { of, from } from 'rxjs';

const obs1 = of(1, 2, 3); // Emite valores individuales
const obs2 = from([10, 20, 30]); // Emite cada valor de un array
```

### ðŸ‘‚ SuscripciÃ³n a un Observable
```ts
obs1.subscribe({
  next: valor => console.log('Valor:', valor),
  error: err => console.error('Error:', err),
  complete: () => console.log('Completado')
});
```
TambiÃ©n podÃ©s suscribirte con una funciÃ³n directa si no necesitas manejar errores:
```ts
obs2.subscribe(valor => console.log(valor));
```

## ðŸ”„ Operadores comunes de RxJS

| Operador     | Uso principal                                                  |
|--------------|----------------------------------------------------------------|
| `map`        | Transformar valores emitidos.                                  |
| `tap`        | Depurar o realizar acciones secundarias.                       |
| `forkJoin`   | Esperar mÃºltiples observables a la vez.                        |
| `mergeMap`   | Combinar flujos mÃºltiples (sin cancelar anteriores).           |
| `switchMap`  | Cancelar solicitudes anteriores y mantener solo la Ãºltima.     |

> ðŸ“Œ **Clave de Ã©xito:** Usar correctamente `pipe` con operadores de **RxJS** te da control total sobre el flujo de datos y mejora la performance de tu app.

## ðŸ§  Diferencias entre Observables y Subjects

| CaracterÃ­stica   | Observables                                 | Subjects                                     |
|------------------|---------------------------------------------|----------------------------------------------|
| **Rol**          | Solo productor de datos                     | Productor y consumidor de datos              |
| **Suscriptores** | Cada uno recibe valores de forma independiente | Todos reciben el mismo flujo de datos     |
| **CreaciÃ³n**     | Usados en tareas especÃ­ficas                | Usados para compartir estados globales       |


## âš”ï¸ `mergeMap` vs `switchMap`

| Operador    | Comportamiento                          |
|-------------|------------------------------------------|
| `mergeMap`  | Conserva todas las suscripciones.        |
| `switchMap` | Cancela suscripciones anteriores.        |

## ðŸ§ª Ejemplo prÃ¡ctico: Fetch con Observables en Angular
```ts
this.http.get('https://jsonplaceholder.typicode.com/users')
  .pipe(
    tap(() => console.log('Cargando usuarios...')),
    map((res: any) => res.slice(0, 5))
  )
  .subscribe(data => {
    this.usuarios = data;
  });
```

## ðŸ§¼ Cancelar suscripciones
Si no gestionÃ¡s bien tus suscripciones, te vas a comer un memory leak ðŸ.
```ts
import { Subscription } from 'rxjs';

export class MiComponente {
  private sub!: Subscription;

  ngOnInit() {
    this.sub = this.servicio.getDatos().subscribe(data => {
      console.log(data);
    });
  }

  ngOnDestroy() {
    this.sub.unsubscribe(); // Â¡LiberÃ¡ memoria!
  }
}
```

## âœ… Resumen

- Los **Observables** permiten trabajar con **flujos de datos asÃ­ncronos**.
- Se pueden crear con `new Observable`, `of`, `from`, etc.
- Se gestionan con operadores como `map`, `tap`, `mergeMap`, etc., y se consumen con `subscribe`.
- âš ï¸ Siempre recordÃ¡ **cancelar las suscripciones** para evitar problemas de memoria (memory leaks).

> ðŸš€ **Dominar los Observables es clave para hacer apps Angular limpias, reactivas y bien organizadas.**

## MÃ©todos next, error y complete en Observables
Los observables en RxJS tienen un ciclo de vida controlado por tres mÃ©todos principales: `next`, `error` y `complete`. Estos mÃ©todos permiten manejar la emisiÃ³n de datos, los errores y la finalizaciÃ³n de un flujo de forma eficiente.

- **MÃ©todos Clave**
    - `next()`:
        - Emite un valor desde el observable al suscriptor.
        - Se usa para enviar datos continuamente mientras el observable estÃ¡ activo.
    - `error()`:
        - Se ejecuta cuando ocurre un error durante el flujo de datos.
        - Detiene la emisiÃ³n de valores y finaliza el flujo inmediatamente.
    - `complete()`:
        - Indica que el flujo de datos ha terminado.
        - No se emiten mÃ¡s valores despuÃ©s de la llamada a `complete()`.
- **Ejemplo PrÃ¡ctico**
    - En este ejemplo, se crea un observable que emite una serie de valores, simula un error de forma aleatoria y, si no hay error, finaliza correctamente.
    ```ts
    import { Observable } from 'rxjs';

    const observable = new Observable(observer => {
        observer.next('Valor 1'); // Emitir primer valor
        observer.next('Valor 2'); // Emitir segundo valor

        if (Math.random() > 0.5) {
            observer.error('OcurriÃ³ un error'); // Emitir error aleatorio
        } else {
            observer.complete(); // Completar el flujo
        }
    });

    observable.subscribe({
        next: valor => console.log('Emitido:', valor),
        error: err => console.error('Error:', err),
        complete: () => console.log('Flujo completado'),
    });
    ```
- **Flujo de Eventos**: El ciclo de vida de un observable varÃ­a segÃºn los eventos que ocurren. A continuaciÃ³n, se ilustran los posibles flujos de eventos.
    - Cuando **no hay errores**:
        - `next('Valor 1') â†’ next('Valor 2') â†’ complete()`
        - Salida esperada:
            - Emitido: Valor 1
            - Emitido: Valor 2
            - Flujo completado
    - Cuando **ocurre un error**:
        - `next('Valor 1') â†’ next('Valor 2') â†’ error('OcurriÃ³ un error')`
        - Salida esperada:
            - Emitido: Valor 1
            - Emitido: Valor 2
            - Error: OcurriÃ³ un error
        - En este flujo, el mÃ©todo error() finaliza inmediatamente la ejecuciÃ³n del observable, por lo que no se llama a complete().

### Aplicaciones en Angular
Los mÃ©todos next, error y complete se utilizan para manejar eventos asincrÃ³nicos, especialmente en flujos de datos generados por observables.
- **Usos de next()**
    - **Solicitudes HTTP**: Captura la respuesta de una API y la procesa.
    - **Eventos de Usuario**: Registra eventos de clic, entrada de texto o interacciones.
    - **EmisiÃ³n de Datos**: Usa `next()` para enviar valores a otros componentes o servicios.
- **Usos de error()**
    - **GestiÃ³n de Errores de API**: Controla errores en solicitudes HTTP (404, 500, etc.).
    - **Notificaciones de Errores**: Muestra mensajes de error en la interfaz de usuario.
    - **Tareas AsÃ­ncronas**: Controla los fallos de promesas o procesos asÃ­ncronos.
- **Usos de complete()**
    - **LiberaciÃ³n de Recursos**: Cierra flujos para liberar memoria.
    - **FinalizaciÃ³n de Observables**: Cierra observables que ya no son necesarios.
    - **Control de Suscripciones**: Evita fugas de memoria al cerrar la suscripciÃ³n de forma controlada.

### ConclusiÃ³n
Los mÃ©todos next, error y complete permiten controlar el ciclo de vida de un observable en Angular.
- next(): Emite datos.
- error(): Gestiona errores de forma controlada.
- complete(): Finaliza el flujo de forma limpia.

Comprender su uso es fundamental para manejar flujos de datos dinÃ¡micos y asincrÃ³nicos, especialmente en aplicaciones reales y reactivas. Estos mÃ©todos permiten controlar la emisiÃ³n de valores, la gestiÃ³n de errores y la finalizaciÃ³n de flujos de manera eficiente.


# **GestiÃ³n Avanzada de Suscripciones en Angular**

## **IntroducciÃ³n**

En Angular, la gestiÃ³n adecuada de suscripciones a observables es fundamental para evitar problemas de **rendimiento** y **fugas de memoria**. Los observables que no se cierran correctamente siguen activos, consumiendo recursos innecesarios, lo que puede provocar una reducciÃ³n de la eficiencia de la aplicaciÃ³n.

## **Problemas Comunes con las Suscripciones**

Cuando los componentes no cierran sus suscripciones al destruirse, los observables continÃºan activos, lo que provoca los siguientes problemas:

- **Fugas de memoria**: Los recursos de la aplicaciÃ³n no se liberan adecuadamente.
- **Baja eficiencia**: Incremento del consumo de memoria y uso del procesador.
- **Inconsistencias**: Se pueden recibir datos de componentes que ya no existen.

## **Estrategias para Gestionar Suscripciones**

### **PatrÃ³n `unsubscribe()`**

El patrÃ³n **`unsubscribe()`** permite cerrar manualmente las suscripciones cuando se destruye el componente. Este mÃ©todo se usa comÃºnmente en el ciclo de vida `ngOnDestroy()`.

### **Ejemplo PrÃ¡ctico**
```ts
import { Observable } from 'rxjs';

const observable = new Observable(observer => {
  observer.next('Valor 1'); // Emitir primer valor
  observer.next('Valor 2'); // Emitir segundo valor

  if (Math.random() > 0.5) {
    observer.error('OcurriÃ³ un error'); // Emitir error aleatorio
  } else {
    observer.complete(); // Completar el flujo
  }
});

observable.subscribe({
  next: valor => console.log('Emitido:', valor),
  error: err => console.error('Error:', err),
  complete: () => console.log('Flujo completado'),
});
```
