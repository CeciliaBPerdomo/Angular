# Guards y seguridad en rutas
Los Guards en Angular son interfaces que se utilizan para controlar el acceso a rutas. Son esenciales para la seguridad y la gesti√≥n de la navegaci√≥n en la aplicaci√≥n. Los Guards se ejecutan antes de acceder a una ruta y pueden permitir o denegar el acceso.

## Tipos de Guards y sus Roles
| üîí **Tipo de Guard**     | ‚öôÔ∏è **Funci√≥n Principal**                                       | üïê **¬øCu√°ndo usarlo?**                                                                 |
|--------------------------|---------------------------------------------------------------|----------------------------------------------------------------------------------------|
| `CanActivate`            | Controla si se puede activar una ruta.                        | Cuando quer√©s bloquear el acceso a una ruta seg√∫n condiciones (ej: usuario logueado). |
| `CanLoad`                | Controla si se puede cargar un m√≥dulo.                        | Para evitar que se descargue c√≥digo de m√≥dulos si el usuario no tiene permisos.       |
| `CanDeactivate`          | Controla si se puede salir de una ruta actual.                | Cuando quer√©s prevenir que se pierdan cambios no guardados al salir de un formulario. |
| `CanActivateChild`       | Controla si se pueden activar rutas hijas.                    | Cuando ten√©s rutas hijas y quer√©s protegerlas igual que la ruta padre.                |


### CanActivate
Determina si el usuario puede activar una ruta antes de acceder a ella.
- Uso com√∫n:
    - Verificar si el usuario est√° autenticado.
    - Comprobar los permisos del usuario.
- Ejemplo:
```typescript 
import { Injectable } from '@angular/core'; 
import { CanActivate } from '@angular/router';

@Injectable({ providedIn: 'root' }) 
export class AuthGuard implements CanActivate { 
    canActivate(): boolean { 
        const isLoggedIn = !!localStorage.getItem('token'); 
        // Solo permite acceso si el usuario est√° autenticado. 
        return isLoggedIn; 
    } 
} 
```

### CanLoad 
Controla si se puede cargar un m√≥dulo de forma diferida (lazy loading).
- Uso com√∫n:
    - Restringir la carga de m√≥dulos para usuarios no autenticados o con roles espec√≠ficos. 
- Ejemplo:
```typescript 
import { Injectable } from '@angular/core'; 
import { CanLoad, Route } from '@angular/router';

@Injectable({ providedIn: 'root' }) 

export class RoleGuard implements CanLoad { 
    canLoad(route: Route): boolean { 
        // Solo carga el m√≥dulo si el usuario es administrador. 
        const userRole = localStorage.getItem('role'); return userRole === 'admin'; 
    } 
}
```

### CanDeactivate 
Determina si el usuario puede salir de la ruta actual. Suele utilizarse para evitar la p√©rdida de cambios no guardados en formularios.
- Uso com√∫n:
    - Solicitar confirmaci√≥n antes de salir de una p√°gina con un formulario no guardado. 
- Ejemplo:
```typescript
import { Injectable } from '@angular/core'; 
import { CanDeactivate } from '@angular/router'; 
import { FormComponent } from './form.component';

@Injectable({ providedIn: 'root' }) 

export class UnsavedChangesGuard implements CanDeactivate { 
    canDeactivate(component: FormComponent): boolean { 
        return component.isFormSaved() || confirm('¬øQuieres salir sin guardar los cambios?'); 
    } 
}
```

#### CanActivateChild 
Controla si se pueden activar rutas hijas de una ruta principal.
- Uso com√∫n:
    - Aplicar reglas de acceso a las subrutas de una secci√≥n.
- Ejemplo:
```typescript
import { Injectable } from '@angular/core'; 
import { CanActivateChild } from '@angular/router';

@Injectable({ providedIn: 'root' }) 

export class ChildGuard implements CanActivateChild { 
    canActivateChild(): boolean { 
        const hasPermission = localStorage.getItem('hasPermission') === 'true'; 
        return hasPermission; // Solo permite acceso si el usuario tiene permisos. 
    } 
} 
```

## Diagrama Representativo de los Guards
- **CanActivate** --> Protege rutas individuales (por ejemplo, /dashboard) 
- **CanLoad** --> Protege la carga de m√≥dulos (por ejemplo, AdminModule) 
- **CanDeactivate** --> Controla la salida de la ruta actual (por ejemplo, /formulario) 
- **CanActivateChild** --> Protege las rutas hijas de una ruta principal (por ejemplo, /dashboard/settings) 

## Conclusi√≥n
Los Guards son fundamentales para garantizar la seguridad y el control de acceso en aplicaciones Angular. Usar `CanActivate`, `CanLoad`, `CanDeactivate` y `CanActivateChild` permite implementar reglas de acceso personalizadas y controlar la navegaci√≥n de la aplicaci√≥n.

# Feature Store en NgRx
Una Feature Store es una porci√≥n del estado global que se encarga de gestionar la l√≥gica de una funcionalidad espec√≠fica, como carrito de compras, usuarios o autenticaci√≥n. Esta t√©cnica permite que cada parte de la aplicaci√≥n tenga su propio estado controlado de forma modular.
- **Ventajas** de la Feature Store 
    - **Modularizaci√≥n**: Facilita la organizaci√≥n del estado. 
    - **Escalabilidad**: El estado se divide en peque√±as secciones manejables. 
    - **Mantenibilidad**: Acciones, reductores y efectos est√°n bien organizados.

## Ejemplo Pr√°ctico: Carrito de Compras
- Definici√≥n del Estado 
```ts
export interface CartState { items: Product[]; total: number; }
export const initialState: CartState = { items: [], total: 0 };
```
- Definici√≥n de Acciones 
```ts
import { createAction, props } from '@ngrx/store';
export const addItem = createAction( '[Cart] Add Item', props<{ item: Product }>() );
export const removeItem = createAction( '[Cart] Remove Item', props<{ id: string }>() );
```
- Creaci√≥n del Reductor 
```ts
import { createReducer, on } from '@ngrx/store'; 
import { addItem, removeItem } from './cart.actions';

export const cartReducer = createReducer( 
    initialState, 
    on(addItem, (state, { item }) => ({ ...state, items: [...state.items, item], total: state.total + item.price })), 
    on(removeItem, (state, { id }) => ({ ...state, items: state.items.filter(item => item.id ! id), 
    total: state.items.filter(item => item.id ! id) .reduce((sum, item) => sum + item.price, 0) })) 
);
```
- Configuraci√≥n del Estado Global 
```ts
import { ActionReducerMap } from '@ngrx/store'; 
import { cartReducer, CartState } from './cart/cart.reducer';

export interface AppState { cart: CartState; }
export const reducers: ActionReducerMap = { cart: cartReducer };
```
- Diagrama Representativo Global State 
    - ‚îú‚îÄ‚îÄ Auth (Feature Store) 
    - ‚îú‚îÄ‚îÄ Cart (Feature Store) 
    - ‚îÇ ‚îú‚îÄ‚îÄ Items 
    - ‚îÇ ‚îî‚îÄ‚îÄ Total 
    - ‚îî‚îÄ‚îÄ Products (Feature Store)

## Conclusi√≥n
Las Feature Stores permiten dividir el estado global de la aplicaci√≥n en segmentos manejables, mejorando la modularizaci√≥n, la mantenibilidad y la escalabilidad de la aplicaci√≥n.

## Selectores de Funciones en NgRx
Los selectores permiten extraer datos del estado de la aplicaci√≥n. Son funciones reutilizables que transforman los datos antes de enviarlos a los componentes.

### Ejemplo Pr√°ctico: Carrito de Compras
- Definici√≥n de Selectores 
```ts
import { createFeatureSelector, createSelector } from '@ngrx/store'; 
import { CartState } from './cart.reducer';

export const selectCartState = createFeatureSelector('cart');
export const selectCartItems = createSelector( selectCartState, (state: CartState) => state.items );
export const selectCartTotal = createSelector( selectCartState, (state: CartState) => state.total );
```
- Uso en un Componente 
```ts
import { Component } from '@angular/core'; 
import { Store } from '@ngrx/store'; 
import { Observable } from 'rxjs'; 
import { selectCartItems, selectCartTotal } from './cart.selectors';

@Component({ 
    selector: 'app-cart', 
    template: <div *ngFor="let item of items$ | async"> {{ item.name }} - {{ item.price | currency }} 
    </div> <p>Total: {{ total$ | async | currency }}</p> 
}) 

export class CartComponent {
    items$: Observable<Product[]>; total$: Observable;
    constructor(private store: Store) { 
        this.items$ = this.store.select(selectCartItems); 
        this.total$ = this.store.select(selectCartTotal); 
    } 
}
```

## Conclusi√≥n
Los selectores permiten extraer y transformar datos de la Feature Store, reduciendo la l√≥gica en los componentes y mejorando la eficiencia de la aplicaci√≥n.